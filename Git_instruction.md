![logo](LogotipGIT.png)

## Работа с Git
## 1.Проверка наличия установленного Git.
В терминале выполнить команду `git version`.

Если Git установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## 2. Установка GIT.
Загружаем последнюю версию Git с сайта https://git-scm.com/downloads. Устанавливаем с настройками по умолчанию.

## 3. Настройка GIT.
При первом использовании Git необходимо представиться. Для этого в терминале нужно ввести две команды:
```
git config --global user.name "Ваше имя английскими буквами"

git config --global user.email ваше почта.
```

## 4. Инициализация репозитория.
Создаем папку в которой будем работать и открываем ее в Visual Studio Code.

Открываем терминал, войдя через верхнее меню вкладка **ВИД**.

В терминале в верхнем правом углу выбираем в каком терминале будем работать. Рекомендация - *Git Bash*.

Получить репозиторий можно двумя способами.
1. Ввести в терминале команду:
```
git init
```
2. Клонировать существующий репозиторий *Git* из любого места. Сделать это можно так:
```
git clone <адрес репозитория>
```
В этой папке *Git* начнет отслеживать все изменения.

В папке создаётся скрытая папка **.git**. В ней ничего менять не надо. Это специальная папка для работы *Git*.


## 5. Запись изменений в репозиторий.
Узнать, что *Git* думает о нашей папке и её содержимом, а также
статус происходящего можно, набрав в терминале команду
```
git status
```
*Git* говорит: пока никаких сохранений у нас нет, и
сохранять, то есть фиксировать нечего.

В нашей папке создаем файл с любым расширением для примера возьмем **.md** (язык разметки Markdown). 

Напишем в появившемся окошке любой текст и **обязательно** сохраним.

Вызвав команду 
```
git status
```
*Git* скажет:

● есть не отслеживаемые файлы — Untracked files;

● файлы появились, но он за ними пока не следит.

В командной строке терминала вводим команду:
*добавить все файлы проекта
```
git add . 
```
*или так
```
git add --all
```
*добавить конкретный файл
```
git add <имя_файла>
```
Узнаем статус через команду 
```
git status
```
*Git* начал отслеживать наши
файлы и пишет:
* некоторые изменения могут быть сохранены;
* указывает на
созданное; 
* появился новый файл и указывет имя его.

Сохранить или зафиксировать
текущий статус можно, набрав в терминале команду
```
git commit -m "<комментарий>"
```
В кавычках - что
надо запомнить, некий комментарий к сохранению. Прияно писать на английском языке.

Изменим наш файл: напишем в нём какой нибудь текст.

Сохраним файл.

В командной строке терминала вводим
```
git diff
```
*Git* выведит все произведённые изменения между сохраненным файлом и зафиксированным (закоммичено).

Несохранив файл, команда *git diff* ничего не покажет (сохранённый файл
полностью идентичен текущему состоянию).

## 6. Просмотр истории коммитов.
Производим подготовку и фиксацию файла через команды
```
git add <имя_файла>

git commit -m "<комментарий>"
```
Вводим в командной строке терминала
```
git log
```
*Git* показывает все наши фиксации с комментариями, датой, автор.

## 7. Перемещение между сохранениями.
Каждая версия файла (фиксация) имеет *commit* - непонятное сочетание букв и
цифр, по которым можем перейти. Копируем их (достаточно 4 символов).

Набираем в командной строке терминала
```
git checkout <скопированные символы> 
```
В окне появилась та версия файла которя храниться за этим скопированным набором символов.

Чтобы вернуться в актуальное стояние - в командной строке терминала
```
git checkout master
```
*Примечание:* Чтобы снова вызвать команду, которую уже писали, не обязательно набирать её заново.
Можно воспользоваться стрелками на клавиатуре. Если нажать стрелочку «вверх», будут
открываться те команды, которые создавались до этого. Вы можете переключаться между
ними.

## 8. Игнорирование файлов
Для того что бы исключить из отслеживания в репозитории файлы и папки необходимо создать там файл ***.gitignore*** и записать в него их название или шаблоны, соответствующие таким файлам или папкам.
## 9. Создание веток и переключение на ветки Git.
Ветка в *Git* - это простой перемещаемый указатель на один из коммитов, обычно последний в цепочке коммитов.
По умолчанию имя основной ветки в *Git* - master.
 
 Создать ветку можно командой:
 ```
 git branch <имя новой ветки>
 ```
 В результате создается новый указатель на текущий коммит.

 Можно изменить имя текущей ветки командой:
 ```
git branch -m <renamed branch>
 ```
Переключение веток аналогично переключению между коммитами, в котором рабочий каталог обновляется в соответствии с выбранной веткой. Переключение на другую ветку можно командой:
```
git checkout <name branch>
```
В происходит обновление файлов в рабочем каталоге в соответствии с версией, хранящейся в этой ветке, а Git начинает записывать все новые коммиты в этой ветке.

Узнать, какие ветки доступны и как называется текущая ветка, можно набрав команду:
```
git branch
```
Создать новую ветку и сразу переключиться на нее можно и одной командой:
```
git checkout -b ＜new-branch＞
```
или
```
git swich -b ＜new-branch＞
```
 
## 10. Слияние веток и разрешение конфликтов.
Для того что бы начать процесс слияния надо перейти на ветку (*host-branch*)- принимающую результаты слияние:
```
git checkout <host-branch>
```
И произвести слияние с нужной веткой (*merge_branch_name*):
```
git merge <merge_branch_name>
```
Не забывайте комитить перед слиянием, так как все действия будут иметь положительный результат только после **сохранения**.

Если в обеих ветках нет конфликтующих изменений, *Git* объединит их автоматически.

При попытке объединить ветки, в которых изменена одна и та же часть того же файла, *Git* не сможет сделать выбор между версиями. В таком случае операция останавливается прямо перед созданием коммита слияния, чтобы пользователь вручную разрешил конфликты.

![conflict](Conflict.png)


Или выбрать из верхнего меню окна нужный вариант

![make_a_choice](MenuConflict.png)

Разрешение конфликтов при слиянии проходит по привычной схеме «редактирование — индексирование — коммит».

При слиянии в *Git* последовательности коммитов объединяются в общую историю.
## 11. Удаление веток.
После слияния веток с разрешением возможных конфликтов в текущую, ненужные ветки можно удалить командой:
```
git branch -d name_branch
```
Если мы попытаемся удалить ветку не слив ее с какой нибудь, *Git* выдаст на предупреждающую строку и предложит варианты наших действий, в том числе и команду принудительного удаления:
```
git branch -D name_branch
```
обратите внимание **D**, а не **d**.
## 12. Работа с удаленным репозиторием на примере сервиса GitHub.
Создать аккаунт на *GitHub* перейдя на сайта https://github.com/.

Создать в своем аккаунте удаленный репозиторий.

Создать (или открыть уже созданный) локальный репозиторий.

"Подружить" свои локальный и удаленный репозитории. *GitHub* при создании нового удаленного репозитория подскажет как это сделать (в локальном репозитрии в терминале набрать команды):

- ```git remote add origin <url скопированный адрес>```
![скопированный адрес](Adress.png)
- ```git push -u origin main ```

Нужно отметить, что в локальном репозитории до проведения вышеуказанных команд ("подружить"):
- все файлы должны быть закомитены;
- ветка *master* переименована в ветку *main* через команду
```
git branch -M main
```
Связано это с тем что в *GitHub* по умолчанию основная ветка называется *main*, а в *Git* - *master*.

Если такая дружба уже произведена, то при повторном обмене информации достаточно будет набрать: 
```
 git push
 ```
 Обновив страничку на *GitHub* мы увидем в репозитории (адрес которого мы копировали) информацию которую отослали с *VS Code*.

 Что бы отослать наоборот из **удаленного репозитория** в **локальный репозиторий** файлы для отправки в удаленном репозитории должны быть сохранены, а в локальном репозитории набрать команду
 ```
 git pull
 ``` 
 Это если локальный и удаленные репозитории предварительно подружили. В противном случае "Git" пропишет команды для решения этой проблемы.

 **Что бы предложить внести свои изменения в репозиторий создается запрос на вливание изменений в репозиторий.**
 
 Заходим в свой аккаунт на *GitHub*
 
 Находим и заходим в репозиторий которому хотим предложить внести свои изменения.
 ![command repository](Com_Rep.png)

Делаем копию, взятого репозитория, в своём аккаунте. Для этого нажимаем *fork*

![Copy](Fork.png)

Даем *Repository name* или оставляем предложенное имя и нажимаем "Great fork" (создаем ветвление).

Копируем адрес созданного репозитория (созданной копии), уже описанным выше способом и перехоходим *VS Code*.

Клонируем созданный репозиторий командой 
```
git clone <скопированный адрес>
```

Обращаем внимание мы должны находились в директории склонированного файла, в противном случае меняем директорию командой
```
cd имя клонированного файла
```
Создать **обязательно** новую ветку например *new* и переходим на неё.

Можно (рекомендуем) создать новый файл и вносим информацию.

Сохраняем (фиксируем) все изменения.

Проверим есть ли связь между локальным и удалённым репозиториями (должна быть так как она установилась когда клонировали) командой:
```
git remote -v
```
Отправляем (выталкиваем) локальный репозиторий в свой удалённый:
```
git push
```
*Git* не может это сделать так как мы в созданной ветке "new", а в удаленном репозитории такой ветки нет. *Git* предложит команды для создания такой ветки в нашем удаленном репозитории и решит эту проблему.

Переходим в наш удалённый репозиторий и обновляем его. Переходим на ветку *new* и видим наш созданный файл.

Нажимаем кнопку 
**Compare & pull request**

Вводим сообщение и комментарии и нажимаем кнопку **Greate pull request**.


